!dict coord_rotate!call "macro_rotate" parameters coord = ogr_data.st.set.path ,ang = 60, axis = 1, bDict=1, RETURNED_PARAMETERS coord_rotateROT_X = 1 : ROT_Y = 2 : ROT_Z = 3 : ROT_FROM_LOC = 4 : ROT_TO_LOC = 5ix = 1 : iy = 2 : iz = 3EPS = 0.0001dim rot_arr[3][3]dim _arr_start[1][3]	_arr_start[1][ix] = 0	_arr_start[1][iy] = 0	_arr_start[1][iz] = 0dim _arr[][]dim _t[][]flag_skip = 1 !При нулевых значениях углов просто возвращаем прежние координатыif bDict then	coord.error = "-"	if not(haskey(coord.in)) then goto "m_end"	if vardim1(coord.in)<2 then goto "m_end"	if haskey(coord.ang) then ang = coord.ang	if haskey(coord.loc.axis) then axis = coord.loc.axis	if haskey(coord.loc.ang_pl) then ang_pl = coord.loc.ang_pl	if haskey(coord.loc.ang_axis) then axis = coord.loc.ang_axis	if haskey(coord.loc.ang_x) then ang_x = coord.loc.ang_x	if haskey(coord.loc.x) then _arr_start[1][ix] = coord.loc.x	if haskey(coord.loc.y) then _arr_start[1][iy] = coord.loc.y	if haskey(coord.loc.z) then _arr_start[1][iz] = coord.loc.z	for i=1 to vardim1(coord.in)		if haskey(coord.in[i].x) then			_arr[i][ix] = coord.in[i].x		else			_arr[i][ix] = 0		endif		if haskey(coord.in[i].y) then			_arr[i][iy] = coord.in[i].y		else			_arr[i][iy] = 0		endif		if haskey(coord.in[i].z) then			_arr[i][iz] = coord.in[i].z		else			_arr[i][iz] = 0		endif	next ielse	_arr = coord_arr	_arr_start = start_coordendifif axis=ROT_FROM_LOC then	flag_skip = 0	ang = ang_axis : axis = ROT_Z : gosub "rot_one_axis"	ang = ang_x : axis = ROT_Y : gosub "rot_one_axis"	ang = ang_pl : axis = ROT_Z : gosub "rot_one_axis"	for i = 1 to vardim1(_arr)		for j = 1 to 3			_arr[i][j] = _arr[i][j]+_arr_start[1][j]		next j	next i	goto "m_end"endifif axis=ROT_TO_LOC then	flag_skip = 0	for i = 1 to vardim1(_arr)		for j = 1 to 3			_arr[i][j] = _arr[i][j]-_arr_start[1][j]		next j	next i	ang = ang_pl : axis = ROT_Z : gosub "rot_one_axis"	ang = ang_x : axis = ROT_Y : gosub "rot_one_axis"	ang = ang_axis : axis = ROT_Z : gosub "rot_one_axis"	goto "m_end"endifif abs(ang)<EPS then	goto "m_end"else	flag_skip = 0endifgosub "rot_one_axis"goto "m_end""rot_one_axis":	if abs(ang)<EPS then return	if axis = ROT_X then gosub "get_mat_x"	if axis = ROT_Y then gosub "get_mat_y"	if axis = ROT_Z then gosub "get_mat_z"	gosub "make_rot"	_arr = _treturn"get_mat_x":	i=0	i=i+1 : rot_arr[i][ix]=1 : rot_arr[i][iy]=0 : rot_arr[i][iz]=0	i=i+1 : rot_arr[i][ix]=0 : rot_arr[i][iy]=cos(ang) : rot_arr[i][iz]=-sin(ang)	i=i+1 : rot_arr[i][ix]=0 : rot_arr[i][iy]=sin(ang) : rot_arr[i][iz]=cos(ang)return"get_mat_y":	i=0	i=i+1 : rot_arr[i][ix]=cos(ang)	: rot_arr[i][iy]=0	: rot_arr[i][iz]=sin(ang)	i=i+1 : rot_arr[i][ix]=0			: rot_arr[i][iy]=1	: rot_arr[i][iz]=0	i=i+1 : rot_arr[i][ix]=-sin(ang)	: rot_arr[i][iy]=0	: rot_arr[i][iz]=cos(ang)return"get_mat_z":	i=0	i=i+1 : rot_arr[i][ix]=cos(ang) : rot_arr[i][iy]=-sin(ang) : rot_arr[i][iz]=0	i=i+1 : rot_arr[i][ix]=sin(ang) : rot_arr[i][iy]=cos(ang) : rot_arr[i][iz]=0	i=i+1 : rot_arr[i][ix]=0 : rot_arr[i][iy]=0 : rot_arr[i][iz]=1return"make_rot":	for i=1 to vardim1(_arr)		for j=1 to 3			_t[i][j] = 0			for k=1 to 3				_t[i][j] = _t[i][j] + _arr[i][k] * rot_arr[k][j]			next k		next j	next ireturn"m_end":if bDict then	if haskey(coord.out) then _d = REMOVEKEY (coord.out)	if flag_skip then		if haskey(coord.in) then coord.out = coord.in	else		for i=1 to vardim1(_t)			coord.out[i].x = _arr[i][ix]			coord.out[i].y = _arr[i][iy]			coord.out[i].z = _arr[i][iz]		next i	endif	coord.error = "ok"	exit coordelse	if flag_skip=0 then coord_arr = _arr	exit coord_arrendif