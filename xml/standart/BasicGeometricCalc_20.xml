<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="A1ABC255-8AE4-41D8-AC50-84F6C6627609" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001
smallEPS = 0.00000001

DIRECTION_POINTS			= 1
MIRROR_VECTOR				= 2
DIRECTION_SEGMENT			= 3
INTERSECT_LINE_LINE			= 4
INTERSECT_CIRCLE_LINE		= 5
INTERSECT_SEGMENT_LINE		= 6
INTERSECT_POLY_LINE			= 7
INSERT_POINT_TO_SEGMENT		= 8
SEGMENT_ARC					= 9
INTERSECT_CIRCLE_CIRCLE		= 10
INTERSECT_SEGMENT_CIRCLE	= 11
DISTRIBUTION_POLY_LINE		= 12
INTERSECT_LINE_LINE_BY_DOT	= 13
DOT_IN_LINE	= 14

if iFunction = DOT_IN_LINE then
	state	= 0
	gosub "IsDotInLine"
	state = IsOnLine
	end state
endif

if iFunction = INTERSECT_LINE_LINE_BY_DOT then
	px1 = Point1x
	py1 = Point1y

	DirectionVx	= 0
	DirectionVy	= 0
	DirectionVz	= 0
	Distance	= 0
	gosub "GetDirectionP2toP1"
	vx1 = DirectionVx
	vy1 = DirectionVy

	px2 = Point4x
	py2 = Point4y
	Point1x = Point3x
	Point1y = Point3y
	Point1z = Point3z
	Point2x = Point4x
	Point2y = Point4y
	Point2z = Point4z

	DirectionVx	= 0
	DirectionVy	= 0
	DirectionVz	= 0
	Distance	= 0
	gosub "GetDirectionP2toP1"
	vx2 = DirectionVx
	vy2 = DirectionVy

	ipx		= 0
	ipy		= 0
	state	= 0
	gosub "LineLineIntersection"
	if state > EPS then
		Point3x_ = Point3x
		Point3y_ = Point3y
		Point3z_ = Point3z

		Point3x = ipx
		Point3y = ipy
		Point3z = 0
		gosub "IsDotInLine"
		IsOnLine1 = IsOnLine


		Point1x = Point3x_
		Point1y = Point3y_
		Point1z = Point3z_
		Point2x = Point4x
		Point2y = Point4y
		Point2z = Point4z
		gosub "IsDotInLine"
		IsOnLine2 = IsOnLine
		if IsOnLine1 then state = 2 + EPS
		if IsOnLine2 then state = 3 + EPS
	endif
	end ipx,
		ipy,
		state
endif

if iFunction = DIRECTION_POINTS then
	DirectionVx	= 0
	DirectionVy	= 0
	DirectionVz	= 0
	Distance	= 0

	gosub "GetDirectionP2toP1"

	end DirectionVx,
		DirectionVy,
		DirectionVz,
		Distance
endif

if iFunction = MIRROR_VECTOR then
	outputVx	= 0
	outputVy	= 0

	gosub "GetMirroredVector"

	end outputVx,
		outputVy
endif

if iFunction = DIRECTION_SEGMENT then
	StartDirectionVx	= 0
	StartDirectionVy	= 0
	EndDirectionVx		= 0
	EndDirectionVy		= 0
	centerArcPx			= 0
	centerArcPy			= 0

	gosub "GetSegmentDirection"

!!!	hotspot2 startPx, startPy, 1
!!!	hotspot2 endPx, endPy, 2
!!!
!!!	if abs(arcAngle) > EPS then
!!!		hotspot2 centerArcPx, centerArcPy, 3
!!!
!!!		poly2_ 4, 1,
!!!			startPx, startPy, 1,
!!!			centerArcPx, centerArcPy, 901,
!!!			0, arcAngle, 4000,
!!!			startPx, startPy, -1
!!!	else
!!!		line2 startPx, startPy, endPx, endPy
!!!	endif
!!!
!!!	pen 20
!!!	add2 startPx, startPy
!!!	line2 0, 0, StartDirectionVx, StartDirectionVy
!!!	del 1
!!!
!!!	pen 6
!!!	add2 endPx, endPy
!!!	line2 0, 0, EndDirectionVx, EndDirectionVy
!!!	del 1

	end StartDirectionVx,
		StartDirectionVy,
		EndDirectionVx,
		EndDirectionVy,
		centerArcPx,
		centerArcPy
endif

if iFunction = INTERSECT_LINE_LINE then
	ipx		= 0
	ipy		= 0
	state	= 0

	gosub "LineLineIntersection"

	end ipx,
		ipy,
		state
endif

if iFunction = INTERSECT_CIRCLE_LINE then
	ipx1	= 0
	ipy1	= 0
	ipx2	= 0
	ipy2	= 0
	state	= 0

	gosub "CircleLineIntersection"

	end ipx1,
		ipy1,
		ipx2,
		ipy2,
		state
endif

if iFunction = INTERSECT_SEGMENT_LINE then
	SegmLineIpx		= 0
	SegmLineIpy		= 0
	SegmLineIp2x	= 0
	SegmLineIp2y	= 0
	SegmLineIpState	= 0

	gosub "SegmentLineIntersection"

	end SegmLineIpx,
		SegmLineIpy,
		SegmLineIp2x,
		SegmLineIp2y,
		SegmLineIpState
endif

if iFunction = INTERSECT_POLY_LINE then
	nIntersectionPoint = 0
	dim IntersectionPoints[][3]

	gosub "PolygonLineIntersection"

	end nIntersectionPoint,
		IntersectionPoints
endif

if iFunction = INSERT_POINT_TO_SEGMENT then
	insertedPx	= 0
	insertedPy	= 0
	insertAngle	= 0

	gosub "InsertPointToSegment"

	end insertedPx,
		insertedPy,
		insertAngle
endif

if iFunction = SEGMENT_ARC then
	dim	insertedPointData[]

	gosub "SegmentsOfArc"

	end insertedPointData
endif

if iFunction = INTERSECT_CIRCLE_CIRCLE then
	ipx1	= 0
	ipy1	= 0
	ipx2	= 0
	ipy2	= 0
	state	= 0

	gosub "CircleCircleIntersection"

	end ipx1,
		ipy1,
		ipx2,
		ipy2,
		state
endif

if iFunction = INTERSECT_SEGMENT_CIRCLE then
	SegmCircIpx		= 0
	SegmCircIpy		= 0
	SegmCircIp2x	= 0
	SegmCircIp2y	= 0
	SegmCircIpState	= 0

	gosub "SegmentCircleIntersection"

	end SegmCircIpx,
		SegmCircIpy,
		SegmCircIp2x,
		SegmCircIp2y,
		SegmCircIpState
endif

if iFunction = DISTRIBUTION_POLY_LINE then
	nDistributorPoints = 0
	dim DistributorPoints[][5]

	gosub "PolylineDistribution"

	end nDistributorPoints,
		DistributorPoints
endif

! =====================================================================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! =====================================================================================================================================


! ===============================================
! Name : IsDotInLine
! -----------------------------------------------
! Input:
!	EPS:		epsylon
!	Point1x:	Coordinate X of the first point
!	Point1y:	Coordinate Y of the first point
!	Point1z:	Coordinate Z of the first point
!	Point2x:	Coordinate X of the second point
!	Point2y:	Coordinate Y of the second point
!	Point2z:	Coordinate Z of the second point
!	Point3x:	Coordinate X of the dot
!	Point3y:	Coordinate Y of the dot
!	Point3z:	Coordinate Z of the dot
! Output:
!	IsOnLine:	1 if dot is on line, 0 otherwise
! ===============================================
"IsDotInLine":
	gosub "GetDirectionP2toP1"
	Dist_line = Distance

	Point1x_ = Point1x
	Point1y_ = Point1y
	Point1z_ = Point1z

	Point1x = Point3x
	Point1y = Point3y
	Point1z = Point3z

	Point2x = Point2x
	Point2y = Point2y
	Point2z = Point2z

	gosub "GetDirectionP2toP1"
	Dist_1_dot = Distance

	Point1x = Point1x
	Point1y = Point1y
	Point1z = Point1z

	Point2x = Point3x
	Point2y = Point3y
	Point2z = Point3z
	gosub "GetDirectionP2toP1"
	Dist_2_dot = Distance
	
	IsOnLine = 0
	if abs(Dist_line-Dist_1_dot-Dist_2_dot)<smallEPS then IsOnLine = 1
return

! ===============================================
! Name : PolygonLineIntersection
! -----------------------------------------------
! Input:
!	EPS:	epsylon
!	PolyCoords:	polygon datas array without closing point
!					[i][1]:		Coordinate X of corner point
!					[i][2]:		Coordinate Y of corner point
!					[i][3]:		angle of segment which starts from corner point
!	vx:		Direction vector X of the line
!	vy:		Direction vector Y of the line
!	px:		Coordinate X of a point of the line
!	py:		Coordinate Y of a point of the line
! Output:
!	IntersectionPoints:	intersection point array
!				[i][1]:		Coordinate X of intersection point
!				[i][2]:		Coordinate Y of intersection point
!				[i][3]:		index of segment which contains the intersection point
!	nIntersectionPoint:	number of intersection points
! Called subroutines:
!	SegmentLineIntersection
! ===============================================

"PolygonLineIntersection":
	nIntersectionPoint = 0
	nVert = vardim1(PolyCoords)

	! line position and direction
	line_vx = vx
	line_vy = vy
	line_px = px
	line_py = py

	for i = 1 to nVert

		! index of next point
		iNext = i + 1
		if (iNext > nVert) then iNext = iNext - nVert

		! current point
		segment_p1x = PolyCoords[i][1]
		segment_p1y = PolyCoords[i][2]
		segment_ang = PolyCoords[i][3]

		! next point
		segment_p2x = PolyCoords[iNext][1]
		segment_p2y = PolyCoords[iNext][2]

		gosub "SegmentLineIntersection"

		if SegmLineIpState > 0 then
			if nIntersectionPoint > 0 then
				if (i = nVert) then
					Distance = sqr((IntersectionPoints[1][1] - SegmLineIpx)**2 + (IntersectionPoints[1][2] - SegmLineIpy)**2)
				else
					Distance = sqr((IntersectionPoints[nIntersectionPoint][1] - SegmLineIpx)**2 + (IntersectionPoints[nIntersectionPoint][2] - SegmLineIpy)**2)
				endif

				if Distance > EPS then
					nIntersectionPoint = nIntersectionPoint + 1
					IntersectionPoints[nIntersectionPoint][1] = SegmLineIpx
					IntersectionPoints[nIntersectionPoint][2] = SegmLineIpy
					IntersectionPoints[nIntersectionPoint][3] = i
				endif

				if SegmLineIpState = 2 then
					if (i = nVert) then
						Distance = sqr((IntersectionPoints[1][1] - SegmLineIp2x)**2 + (IntersectionPoints[1][2] - SegmLineIp2y)**2)
					else
						Distance = sqr((IntersectionPoints[nIntersectionPoint][1] - SegmLineIp2x)**2 + (IntersectionPoints[nIntersectionPoint][2] - SegmLineIp2y)**2)
					endif

					if Distance > EPS then
						nIntersectionPoint = nIntersectionPoint + 1
						IntersectionPoints[nIntersectionPoint][1] = SegmLineIp2x
						IntersectionPoints[nIntersectionPoint][2] = SegmLineIp2y
						IntersectionPoints[nIntersectionPoint][3] = i
					endif
				endif
			else
				nIntersectionPoint = nIntersectionPoint + 1
				IntersectionPoints[nIntersectionPoint][1] = SegmLineIpx
				IntersectionPoints[nIntersectionPoint][2] = SegmLineIpy

				if (abs(segment_p1x - SegmLineIpx) < EPS) & (abs(segment_p1y - SegmLineIpy) < EPS) then
					if (i = 1) then
						IntersectionPoints[nIntersectionPoint][3] = nVert
					else
						IntersectionPoints[nIntersectionPoint][3] = i - 1
					endif
				else
					IntersectionPoints[nIntersectionPoint][3] = i
				endif

				if SegmLineIpState = 2 then
					nIntersectionPoint = nIntersectionPoint + 1
					IntersectionPoints[nIntersectionPoint][1] = SegmLineIp2x
					IntersectionPoints[nIntersectionPoint][2] = SegmLineIp2y

					if (abs(segment_p1x - SegmLineIp2x) < EPS) & (abs(segment_p1y - SegmLineIp2y) < EPS) then
						if (i = 1) then
							IntersectionPoints[nIntersectionPoint][3] = nVert
						else
							IntersectionPoints[nIntersectionPoint][3] = i - 1
						endif
					else
						IntersectionPoints[nIntersectionPoint][3] = i
					endif
				endif
			endif
		endif

	next i
return

! ===============================================
! Name : SegmentLineIntersection
! -----------------------------------------------
! Input:
!	EPS:			epsylon
!	line_vx:		Direction vector X of the line
!	line_vy:		Direction vector Y of the line
!	line_px:		Coordinate X of a point of the line
!	line_py:		Coordinate Y of a point of the line
!	segment_p1x:	segment startpoint X
!	segment_p1y:	segment startpoint Y
!	segment_p2x:	segment endpoint X
!	segment_p2y:	segment endpoint Y
!	segment_ang:	segment angle
! Output:
!	SegmLineIpx:	Coordinate X of intersection point
!	SegmLineIpy:	Coordinate Y of intersection point
!	SegmLineIp2x:	Coordinate X of second intersection point in case of arched segment
!	SegmLineIp2y:	Coordinate Y of second intersection point in case of arched segment
!	SegmLineIpState:	output status
!						 0: no intersection, parallel lines
!						 1: one intersection
!						 2: two intersections, it is possible in case of arched segment
! Called subroutines:
!	GetDirectionP2toP1
!	LineLineIntersection
!	CircleLineIntersection
! ===============================================

"SegmentLineIntersection":
	! initialize output parameters
	SegmLineIpx		= 0
	SegmLineIpy		= 0
	SegmLineIp2x	= 0
	SegmLineIp2y	= 0
	SegmLineIpState	= 0

	! compute inputs
	Point1x = segment_p2x
	Point1y = segment_p2y
	Point1z = 0

	Point2x = segment_p1x
	Point2y = segment_p1y
	Point2z = 0

	gosub "GetDirectionP2toP1"

	segment_vx		= DirectionVx
	segment_vy		= DirectionVy
	segment_length	= Distance

	SegmLineIpState = 0

	if abs(segment_ang) < EPS then		! straight segment
										! ----------------

		! line inputs
		vx1 = line_vx
		vy1 = line_vy
		px1 = line_px
		py1 = line_py

		! segment inputs
		vx2 = segment_vx
		vy2 = segment_vy
		px2 = segment_p1x
		py2 = segment_p1y

		gosub "LineLineIntersection"

		! looking for intersection point on 
		if state > 0 then

			Point1x = segment_p1x
			Point1y = segment_p1y
			Point1z = 0

			Point2x = ipx
			Point2y = ipy
			Point2z = 0

			gosub "GetDirectionP2toP1"

			DistS1_IP = Distance


			Point1x = segment_p2x
			Point1y = segment_p2y
			Point1z = 0

			Point2x = ipx
			Point2y = ipy
			Point2z = 0

			gosub "GetDirectionP2toP1"

			DistS2_IP = Distance


			if ( ((DistS1_IP + DistS2_IP) - segment_length) < EPS ) then		! intersection point lies on segment
				SegmLineIpx = ipx
				SegmLineIpy = ipy

				SegmLineIpState = 1
			endif
		endif

	else				! arched segment
						! --------------

		! line inputs
		linePx = line_px
		linePy = line_py

		lineVx = line_vx
		lineVy = line_vy

		! circle inputs
		ro = (segment_length/2)/sin(abs(segment_ang/2))

		if segment_ang < 0 then
			ArcDirectionVx = -segment_vy
			ArcDirectionVy = segment_vx
		else
			ArcDirectionVx = segment_vy
			ArcDirectionVy = -segment_vx
		endif

		xo = segment_p1x + (segment_length/2) * DirectionVx - (sqr((ro)^2 - (segment_length/2)^2)) * ArcDirectionVx
		yo = segment_p1y + (segment_length/2) * DirectionVy - (sqr((ro)^2 - (segment_length/2)^2)) * ArcDirectionVy

!!!		circle2 xo, yo, ro

		gosub "CircleLineIntersection"


		! no intersection point
		if state = 0 then
			SegmLineIpState = 0
		endif

		! one intersection point (tangential line), not used
		if state = 1 then
			SegmLineIpState = 0
		endif

		! two intersection point
		if state = 2 then

			! check (a) intersection point
			if	( (abs(segment_p1x - ipx1) < EPS) & (abs(segment_p1y - ipy1) < EPS) ) |\
				( (abs(segment_p2x - ipx1) < EPS) & (abs(segment_p2y - ipy1) < EPS) ) then

				SegmLineIpx = ipx1
				SegmLineIpy = ipy1

				SegmLineIpState = 1
			else
				! get intersection point
				vx1 = -segment_vy
				vy1 = segment_vx
				px1 = ipx1
				py1 = ipy1

				vx2 = segment_vx
				vy2 = segment_vy
				px2 = segment_p1x
				py2 = segment_p1y

				gosub "LineLineIntersection"

				! get direction vector
				Point1x = ipx1
				Point1y = ipy1
				Point1z = 0

				Point2x = ipx
				Point2y = ipy
				Point2z = 0

				gosub "GetDirectionP2toP1"

				Scalar = ( (ArcDirectionVx * DirectionVx) + (ArcDirectionVy * DirectionVy) )

				! if direction vector which shows from segment to circle-line intersection point is same to arch direction then the point lies the arched segment
				if (abs(Scalar - 1) < EPS) then
					SegmLineIpx = ipx1
					SegmLineIpy = ipy1

					SegmLineIpState = 1
				endif
			endif

			! check (b) intersection point
			if	( (abs(segment_p1x - ipx2) < EPS) & (abs(segment_p1y - ipy2) < EPS) ) |\
				( (abs(segment_p2x - ipx2) < EPS) & (abs(segment_p2y - ipy2) < EPS) ) then

				if SegmLineIpState = 1 then
					SegmLineIp2x = ipx2
					SegmLineIp2y = ipy2
				else
					SegmLineIpx = ipx2
					SegmLineIpy = ipy2
				endif

				SegmLineIpState = SegmLineIpState + 1
			else
				! get intersection point
				vx1 = -segment_vy
				vy1 = segment_vx
				px1 = ipx2
				py1 = ipy2

				vx2 = segment_vx
				vy2 = segment_vy
				px2 = segment_p1x
				py2 = segment_p1y

				gosub "LineLineIntersection"

				! get direction vector
				Point1x = ipx2
				Point1y = ipy2
				Point1z = 0

				Point2x = ipx
				Point2y = ipy
				Point2z = 0

				gosub "GetDirectionP2toP1"

				Scalar = ( (ArcDirectionVx * DirectionVx) + (ArcDirectionVy * DirectionVy) )

				! if direction vector which shows from segment to circle-line intersection point is same to arch direction
				if (abs(Scalar - 1) < EPS) then
					if SegmLineIpState = 1 then
						SegmLineIp2x = ipx2
						SegmLineIp2y = ipy2
					else
						SegmLineIpx = ipx2
						SegmLineIpy = ipy2
					endif

					SegmLineIpState = SegmLineIpState + 1
				endif
			endif

		endif
	
	endif
return

! ===============================================
! Name : GetDirectionP2toP1
! -----------------------------------------------
! Duplicated in basicStairRiser_m builtin macro
! Input:
!	EPS:		epsylon
!	Point1x:	Coordinate X of the first point
!	Point1y:	Coordinate Y of the first point
!	Point1z:	Coordinate Z of the first point
!	Point2x:	Coordinate X of the second point
!	Point2y:	Coordinate Y of the second point
!	Point2z:	Coordinate Z of the second point
! Output:
!	DirectionVx, DirectionVy, DirectionVz:	vector from second to first point
!	Distance:	Distance between two point
! ===============================================

"GetDirectionP2toP1":
	! Calculate distance
	Distance = Sqr((Point1x - Point2x)^2 + (Point1y - Point2y)^2 + (Point1z - Point2z)^2)

	! direction vector from Point2 to Point1
	if Distance > smallEPS then
		DirectionVx = min(1, max(-1, (Point1x - Point2x)/Distance))
		DirectionVy = min(1, max(-1, (Point1y - Point2y)/Distance))
		DirectionVz = min(1, max(-1, (Point1z - Point2z)/Distance))
	else
		DirectionVx = 0
		DirectionVy = 0
		DirectionVz = 0
	endif
return


! ===============================================
! Name : LineLineIntersection
! -----------------------------------------------
! Input:
!	EPS:	epsylon
!	vx1:	Direction vector X of the line
!	vy1:	Direction vector Y of the line
!	px1:	Coordinate X of a point of the line
!	py1:	Coordinate Y of a point of the line
!	vx2:	Direction vector X of the line
!	vy2:	Direction vector Y of the line
!	px2:	Coordinate X of a point of the line
!	py2:	Coordinate Y of a point of the line
! Output:
!	ipx:	Distance between a point and a line
!	ipy:	Distance between a point and a line
!	state:			output status
!						 0: no intersection, parallel lines
!						 1: lines are intersects
! ===============================================

"LineLineIntersection":
	Scalar = ( (vx1*vx2) + (vy1*vy2) )

	if abs(abs(Scalar) - 1) < EPS then
		! no intersection, parallel lines
		ipx = 0
		ipy = 0
		state = 0
	else
		! Calculate A1, B1 and C1 parameter
		! A1, B1 are equal to normal vector
		A1 = -vy1
		B1 = vx1
		C1 = -(A1*px1) - (B1*py1)

		! Calculate A2, B2 and C2 parameter
		! A2, B2 are equal to normal vector
		A2 = -vy2
		B2 = vx2
		C2 = -(A2*px2) - (B2*py2)

		! Calculate coordinates of intersection point
		if abs((B1*A2) - (A1*B2))>EPS then
			ipy = ((A1*C2) - (C1*A2)) / ((B1*A2) - (A1*B2))
			state = 1
		else
			ipy = 0
			state = 0
text2 0,0,"ERR"
		endif

		if abs(A1) < EPS then
			ipx = (-B2*ipy - C2) / A2
		else
			ipx = (-B1*ipy - C1) / A1
		endif
	endif
return

! ==============================================================================
! CircleLineIntersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo, yo:				circle center point
!	ro:					circle radius
!	lineVx, lineVy		direction vector of the line
!	linePx, linePy		a point of the line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	ipx1, ipy1:			intersection point #1
!	ipx2, ipy2:			intersection point #2
! ==============================================================================

"CircleLineIntersection":

	! compute perpendicular distance from circle center to line
	! ---------------------------------------------------------

	! compute perpendicular direction vector from circle center to line
	_circLineVx	= -lineVy
	_circLineVy	= lineVx

!!!	add2 linePx, linePy
!!!	line2 0, 0, lineVx, lineVy
!!!	del 1
!!!
!!!	add2 xo, yo
!!!	line2 0, 0, _circLineVx, _circLineVy
!!!	del 1

	vx1 = lineVx
	vy1 = lineVy
	px1 = linePx
	py1 = linePy

	vx2 = _circLineVx
	vy2 = _circLineVy
	px2 = xo
	py2 = yo

	gosub "LineLineIntersection"

!!!	pen 40
!!!	hotspot2 ipx, ipy
!!!	circle2 ipx, ipy, 0.015

	! compute distance between circle center and intersection of line and perpendicular direction from circle center
	Point1x = xo
	Point1y = yo
	Point1z = 0

	Point2x = ipx
	Point2y = ipy
	Point2z = 0

	gosub "GetDirectionP2toP1"


	if ( abs(Distance - ro) < EPS ) then
		! Tangential intersection
		! -----------------------
		state = 1

		ipx1 = ipx
		ipy1 = ipy
		ipx2 = ipx1
		ipy2 = ipy1
	else
		if (Distance < ro) then
			! Two intersection
			! ----------------
			state = 2

			! distance in direction of the line
			_distOnLine = sqr(ro^2 - Distance^2)

			ipx1 = ipx + _distOnLine * lineVx
			ipy1 = ipy + _distOnLine * lineVy
			ipx2 = ipx - _distOnLine * lineVx
			ipy2 = ipy - _distOnLine * lineVy
		else
			! No intersection
			! ---------------
			state = 0

			ipx1 = 0
			ipy1 = 0
			ipx2 = 0
			ipy2 = 0
		endif
	endif

!!!	if (state > 0) then
!!!		pen 20
!!!		hotspot2 ipx1, ipy1
!!!		circle2 ipx1, ipy1, 0.03
!!!	endif
!!!
!!!	if (state > 1) then
!!!		pen 6
!!!		hotspot2 ipx2, ipy2
!!!		circle2 ipx2, ipy2, 0.05
!!!	endif
!!!
!!!	text2 0, -1.5, state
return

! ===============================================
! Name : GetSegmentDirection
! if segment is arched the vector is tangential of arch
! -----------------------------------------------
! Duplicated in basicStairRiser_m builtin macro
! Input:
!	startPx:	Segment Starting Point X
!	startPy:	Segment Starting Point Y
!	endPx:		Segment Ending Point X
!	endPy:		Segment Ending Point Y
!	arcAngle:	Angle of Arched Segment
! Output:
!	StartDirectionVx:	Direction Vector X in Starting Point
!	StartDirectionVy:	Direction Vector Y in Starting Point
!	EndDirectionVx:		Direction Vector X in Ending Point
!	EndDirectionVy:		Direction Vector Y in Ending Point
!	centerArcPx:		Center X of Arched Segment
!	centerArcPy:		Center Y of Arched Segment
! Called subroutines:
!	GetDirectionP2toP1
!	GetArchSegmentDirection
! ===============================================

"GetSegmentDirection":
	if ( abs(arcAngle) < EPS ) then
		Point1x = endPx
		Point1y = endPy
		Point1z = 0

		Point2x = startPx
		Point2y = startPy
		Point2z = 0

		gosub "GetDirectionP2toP1"

		StartDirectionVx = DirectionVx
		StartDirectionVy = DirectionVy

		EndDirectionVx = -DirectionVx
		EndDirectionVy = -DirectionVy
	else
		startArcPx	= startPx
		startArcPy	= startPy

		endArcPx	= endPx
		endArcPy	= endPy

		arcAngle	= arcAngle

		gosub "GetArchSegmentDirection"

		StartDirectionVx = startTangentialVx
		StartDirectionVy = startTangentialVy

		EndDirectionVx = endTangentialVx
		EndDirectionVy = endTangentialVy
	endif
return

! ===============================================
! Name : GetArchSegmentDirection
! -----------------------------------------------
! Duplicated in basicStairRiser_m builtin macro
! Input:
!	EPS:		epsylon
!	startArcPx:	Coordinate X of the start point
!	startArcPy:	Coordinate Y of the start point
!	endArcPx:	Coordinate X of the end point
!	endArcPy:	Coordinate Y of the end point
!	arcAngle:	angle of arch
! Output:
!	startTangentialVx:	Tangential Vector X on Start
!	startTangentialVy:	Tangential Vector Y on Start
!	endTangentialVx:	Tangential Vector X on End
!	endTangentialVy:	Tangential Vector Y on End
! Called subroutines:
!	GetDirectionP2toP1
!	GetMirroredVector
! ===============================================

"GetArchSegmentDirection":
	Point1x = endArcPx
	Point1y = endArcPy
	Point1z = 0

	Point2x = startArcPx
	Point2y = startArcPy
	Point2z = 0

	gosub "GetDirectionP2toP1"

	arcR = (Distance/2) / sin(abs(arcAngle/2))

	if ((arcAngle < 0) & (arcAngle > -180)) | (arcAngle > 180) then
		ArcDirectionVx = -DirectionVy
		ArcDirectionVy = DirectionVx
	else
		ArcDirectionVx = DirectionVy
		ArcDirectionVy = -DirectionVx
	endif

	centerArcPx = startArcPx + (Distance/2) * DirectionVx - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVx
	centerArcPy = startArcPy + (Distance/2) * DirectionVy - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVy

	Point1x = startArcPx
	Point1y = startArcPy
	Point1z = 0

	Point2x = centerArcPx
	Point2y = centerArcPy
	Point2z = 0

	gosub "GetDirectionP2toP1"

	VXx = DirectionVx
	VXy = DirectionVy

	VYx = -DirectionVy
	VYy = DirectionVx


	! Set tangential vector on start
	! ------------------------------
	startTangentialVx = -DirectionVy
	startTangentialVy = DirectionVx

	_scalar = ArcDirectionVx*startTangentialVx + ArcDirectionVy*startTangentialVy
	if (arcAngle < -180 + EPS) | (arcAngle > 180) then _scalar = -_scalar
	if sgn(_scalar) = -1 then
		startTangentialVx = -startTangentialVx
		startTangentialVy = -startTangentialVy
	endif

	! Calculation to be in range [-1, 1]
	! ----------------------------------
	startTangentialVx = min(1, max(-1, startTangentialVx))
	startTangentialVy = min(1, max(-1, startTangentialVy))


	! Set tangential vector on end
	! ----------------------------
	mirrorVx = ArcDirectionVx
	mirrorVy = ArcDirectionVy

	inputVx	= startTangentialVx
	inputVy	= startTangentialVy

	gosub "GetMirroredVector"

	endTangentialVx = min(1, max(-1, outputVx))
	endTangentialVy = min(1, max(-1, outputVy))
return

! ===============================================
! Name : GetMirroredVector
! -----------------------------------------------
! Duplicated in basicStairRiser_m builtin macro
! Input:
!	mirrorVx:	Direction X of Mirroring Vector
!	mirrorVy:	Direction Y of Mirroring Vector
!	inputVx: 	Direction X of Vector which has to Mirror
!	inputVy:	Direction Y of Vector which has to Mirror
! Output:
!	outputVx:	Direction X of Mirrored Vector
!	outputVy:	Direction Y of Mirrored Vector
! ===============================================

"GetMirroredVector":
	outputVx = -inputVx + (2 * (inputVx * mirrorVx + inputVy * mirrorVy) * mirrorVx)
	outputVy = -inputVy + (2 * (inputVx * mirrorVx + inputVy * mirrorVy) * mirrorVy)
return

! ===============================================
! Name : InsertPointToSegment
! if segment is arched the vector is tangential of arch
! -----------------------------------------------
! Input:
!	EPS:			epsylon
!	insertionToPx:	Insert Point to this Point X
!	insertionToPy:	Insert Point to this Point Y
!	benchmarkPx:	Benchmark Point X to Control Direction of Insertion
!	benchmarkPy:	Benchmark Point Y to Control Direction of Insertion
!	segmentAngle:	Angle of Arched Segment
!	insertionDist:	Insertion Distance
! Output:
!	insertedPx:		Inserted Point X
!	insertedPy:		Inserted Point Y
!	insertAngle:	Angle between Insertion to Point and Inserted Point
! Called subroutines:
!	GetDirectionP2toP1
! ===============================================

"InsertPointToSegment":
	if ( abs(segmentAngle) < EPS) then

		Point1x = benchmarkPx
		Point1y = benchmarkPy
		Point1z = 0

		Point2x = insertionToPx
		Point2y = insertionToPy
		Point2z = 0

		gosub "GetDirectionP2toP1"

		insertedPx = insertionToPx + DirectionVx * insertionDist
		insertedPy = insertionToPy + DirectionVy * insertionDist

		insertAngle = 0
	else
		startArcPx	= insertionToPx
		startArcPy	= insertionToPy

		endArcPx 	= benchmarkPx
		endArcPy 	= benchmarkPy

		Point1x = endArcPx
		Point1y = endArcPy
		Point1z = 0

		Point2x = startArcPx
		Point2y = startArcPy
		Point2z = 0

		gosub "GetDirectionP2toP1"

		arcR = (Distance/2) / sin(abs(segmentAngle/2))

		if ((segmentAngle < 0) & (segmentAngle > -180)) | (segmentAngle > 180) then
			ArcDirectionVx = -DirectionVy
			ArcDirectionVy = DirectionVx
		else
			ArcDirectionVx = DirectionVy
			ArcDirectionVy = -DirectionVx
		endif

		centerArcPx = startArcPx + (Distance/2) * DirectionVx - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVx
		centerArcPy = startArcPy + (Distance/2) * DirectionVy - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVy

!!!		add2 centerArcPx, centerArcPy
!!!		line2 0, 0, ArcDirectionVx, ArcDirectionVy
!!!		circle2 0, 0,  0.02
!!!		del 1

		! hurhosszban ertelmezve
!		insertAngle = 2*( asn((_insertionDist/2) / arcR) )

		! ivhosszban ertelmezve
		archLength = abs( arcR*(pi/180)*segmentAngle )
		insertAngle = (abs(segmentAngle)/archLength) * insertionDist

		! forgatas iranya az segmentAngle szerint
		insertAngle = insertAngle * sgn(segmentAngle)

		localRotPx = arcR * cos(insertAngle)
		localRotPy = arcR * sin(insertAngle)

		! Global trafo to locally rotated point
		Point1x = insertionToPx
		Point1y = insertionToPy
		Point1z = 0

		Point2x = centerArcPx
		Point2y = centerArcPy
		Point2z = 0

		gosub "GetDirectionP2toP1"

		TrafoVXx = DirectionVx
		TrafoVXy = DirectionVy

		TrafoVYx = -DirectionVy
		TrafoVYy = DirectionVx

!!!		add2 centerArcPx, centerArcPy
!!!		line2 0, 0, TrafoVXx/2, TrafoVXy/2
!!!		line2 0, 0, TrafoVYx/2, TrafoVYy/2
!!!		del 1

		! Move (centerArcP) and rotate (TrafoVX, TrafoVY) locally rotated point to globally coordinate system
		insertedPx = TrafoVXx * localRotPx + TrafoVYx * localRotPy + centerArcPx
		insertedPy = TrafoVXy * localRotPx + TrafoVYy * localRotPy + centerArcPy
	endif
return

! ===============================================
! Name : SegmentsOfArc
! if segment is arched the vector is tangential of arch
! -----------------------------------------------
! Input:
!	EPS:		epsylon
!	startPx:	Coordinate X of the start point
!	startPy:	Coordinate Y of the start point
!	endPx:		Coordinate X of the end point
!	endPy:		Coordinate Y of the end point
!	arcAngle:	angle of arch
!	TolerDiff:	Tolerance of Arc
! Output:
!	insertedPointData:		Coordinates Array of Inserted Points ([2n+1] = X; [2n+2] = Y)
! Called subroutines:
!	GetSegmentDirection
!	InsertPointToSegment
! ===============================================

"SegmentsOfArc":
	gosub "GetSegmentDirection"

	_arcRadius = sqr( (startPx - centerArcPx)**2 + (startPy - centerArcPy)**2 )

	_calculatedSegmentAngle = 2 * ACS((_arcRadius - TolerDiff)/_arcRadius)

	if arcAngle < EPS then
		_segmentNumber = ABS(INT(arcAngle / _calculatedSegmentAngle))
	else
		_segmentNumber = CEIL(arcAngle / _calculatedSegmentAngle)
	endif

	_currX = startPx
	_currY = startPy

	insertedPointData[1] = _currX
	insertedPointData[2] = _currY

	for i = 1 to _segmentNumber
		insertionToPx	= _currX
		insertionToPy	= _currY

		benchmarkPx		= endPx
		benchmarkPy		= endPy
		insertionDist	= abs((arcAngle / 360) * 2 * _arcRadius * PI / _segmentNumber)
		segmentAngle	= arcAngle - (i-1) * arcAngle / _segmentNumber

		gosub "InsertPointToSegment"

		_currX = insertedPx
		_currY = insertedPy

		insertedPointData[2*i+1] = _currX
		insertedPointData[2*i+2] = _currY
	next i

return


! ===============================================
! Name : CircleCircleIntersection
! -----------------------------------------------
! Input variables:
!	EPS:				epsylon
!	circleAcx:			Circle A Center Point X
!	circleAcy:			Circle A Center Point Y
!	circleAr:			Circle A Radius
!	circleBcx:			Circle B Center Point X
!	circleBcy:			Circle B Center Point Y
!	circleBr:			Circle B Radius
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential circle)
!						2 = two intersection points
!	ipx1, ipy1:			intersection point #1
!	ipx2, ipy2:			intersection point #2
! ===============================================

"CircleCircleIntersection":

	! looking for intersection points in local coordinate system which derived from center points of circles

	Point1x = circleBcx
	Point1y = circleBcy
	Point1z = 0

	Point2x = circleAcx
	Point2y = circleAcy
	Point2z = 0

	gosub "GetDirectionP2toP1"

	! initialize parameters
	_ipx1 = 0
	_ipy1 = 0

	_ipx2 = 0
	_ipy2 = 0

	state = 0
	if	( abs(Distance - (circleAr + circleBr)) < EPS ) |\
		( abs(Distance - abs(circleAr - circleBr)) < EPS ) then

		state = 1

		if ( abs(Distance - (circleAr + circleBr)) < EPS ) then
			_ipx1 = circleAr
			_ipy1 = 0
		else
			_ipx1 = -circleAr
			_ipy1 = 0
		endif
	else
		if ( Distance < (circleAr + circleBr) ) &\
			( Distance > abs(circleAr - circleBr) ) then

			state = 2

			IPx = (Distance^2 - circleBr^2 + circleAr^2) / (2*Distance)
			IPy = sqr(circleAr^2 - IPx^2)

			_ipx1 = IPx
			_ipy1 = IPy

			_ipx2 = IPx
			_ipy2 = -IPy
		endif
	endif

	! Convert intersection points to global coordinate system

	TrafoPx = circleAcx
	TrafoPy = circleAcy

	TrafoVXx = DirectionVx
	TrafoVXy = DirectionVy

	TrafoVYx = -DirectionVy
	TrafoVYy = DirectionVx

	ipx1 = TrafoVXx * _ipx1 + TrafoVYx * _ipy1 + TrafoPx
	ipy1 = TrafoVXy * _ipx1 + TrafoVYy * _ipy1 + TrafoPy

	ipx2 = TrafoVXx * _ipx2 + TrafoVYx * _ipy2 + TrafoPx
	ipy2 = TrafoVXy * _ipx2 + TrafoVYy * _ipy2 + TrafoPy

!!!	pen 6
!!!	line2 0, 0, TrafoVXx, TrafoVXy
!!!	pen 20
!!!	line2 0, 0, TrafoVYx, TrafoVYy
!!!
!!!	pen 20
!!!	hotspot2 ipx1, ipy1
!!!	pen 6
!!!	hotspot2 ipx2, ipy2
!!!
!!!	text2 -1, 0, state

return

! ===============================================
! Name : SegmentCircleIntersection
! -----------------------------------------------
! Input:
!	EPS:			epsylon
!	circleCx:		Circle Center Point X
!	circleCy:		Circle Center Point Y
!	circleR:		Circle Radius
!	segmP1x:		segment startpoint X
!	segmP1y:		segment startpoint Y
!	segmP2x:		segment endpoint X
!	segmP2y:		segment endpoint Y
!	segmAng:		segment angle
! Output:
!	SegmCircIpx:	Coordinate X of intersection point
!	SegmCircIpy:	Coordinate Y of intersection point
!	SegmCircIp2x:	Coordinate X of second intersection point
!	SegmCircIp2y:	Coordinate Y of second intersection point
!	SegmCircIpState:	output status
!						 0: no intersection
!						 1: one intersection
!						 2: two intersections
! Called subroutines:
!	GetDirectionP2toP1
!	CircleCircleIntersection
!	CircleLineIntersection
! ===============================================

"SegmentCircleIntersection":

	! initialize output parameters
	SegmCircIpx		= 0
	SegmCircIpy		= 0
	SegmCircIp2x	= 0
	SegmCircIp2y	= 0
	SegmCircIpState	= 0

	! compute inputs
	Point1x = segmP2x
	Point1y = segmP2y
	Point1z = 0

	Point2x = segmP1x
	Point2y = segmP1y
	Point2z = 0

	gosub "GetDirectionP2toP1"

	segment_vx		= DirectionVx
	segment_vy		= DirectionVy
	segment_length	= Distance

	SegmCircIpState = 0

	if abs(segmAng) < EPS then		! straight segment
									! ----------------

!!!		line2 segmP1x, segmP1y, segmP2x, segmP2y

		linePx = segmP1x
		linePy = segmP1y

		lineVx = segment_vx
		lineVy = segment_vy

		xo = circleCx
		yo = circleCy

		ro = circleR

		gosub "CircleLineIntersection"

!!!		text2 0, 0, state
!!!		circle2 ipx1, ipy1, 0.01
!!!		circle2 ipx2, ipy2, 0.02

		if (state > 0) then

			! Check first intersection point
			Point1x = segmP1x
			Point1y = segmP1y
			Point1z = 0

			Point2x = ipx1
			Point2y = ipy1
			Point2z = 0

			gosub "GetDirectionP2toP1"

			DistS1_IP = Distance


			Point1x = segmP2x
			Point1y = segmP2y
			Point1z = 0

			Point2x = ipx1
			Point2y = ipy1
			Point2z = 0

			gosub "GetDirectionP2toP1"

			DistS2_IP = Distance


			if ( ((DistS1_IP + DistS2_IP) - segment_length) < EPS ) then		! intersection point lies on segment
				SegmCircIpx = ipx1
				SegmCircIpy = ipy1

				SegmCircIpState = 1
			endif

			! Check second intersection point
			if (state = 2) then

				Point1x = segmP1x
				Point1y = segmP1y
				Point1z = 0

				Point2x = ipx2
				Point2y = ipy2
				Point2z = 0

				gosub "GetDirectionP2toP1"

				DistS1_IP = Distance


				Point1x = segmP2x
				Point1y = segmP2y
				Point1z = 0

				Point2x = ipx2
				Point2y = ipy2
				Point2z = 0

				gosub "GetDirectionP2toP1"

				DistS2_IP = Distance

				if ( ((DistS1_IP + DistS2_IP) - segment_length) < EPS ) then		! intersection point lies on segment
					if SegmCircIpState = 0 then
						SegmCircIpx = ipx2
						SegmCircIpy = ipy2

						SegmCircIpState = 1
					else
						SegmCircIp2x = ipx2
						SegmCircIp2y = ipy2

						SegmCircIpState = SegmCircIpState + 1
					endif
				endif

			endif

		endif

	else				! arched segment
						! --------------

		segmR = (Distance/2) / sin(abs(segmAng/2))

		if ((segmAng < 0) & (segmAng > -180)) | (segmAng > 180) then
			ArcDirectionVx = -DirectionVy
			ArcDirectionVy = DirectionVx
		else
			ArcDirectionVx = DirectionVy
			ArcDirectionVy = -DirectionVx
		endif

		centerSegmPx = segmP1x + (Distance/2) * DirectionVx - (sqr((segmR)^2 - (Distance/2)^2)) * ArcDirectionVx
		centerSegmPy = segmP1y + (Distance/2) * DirectionVy - (sqr((segmR)^2 - (Distance/2)^2)) * ArcDirectionVy

!!!		hotspot2 centerSegmPx, centerSegmPy
!!!
!!!		poly2_ 4, 1,
!!!			segmP1x, segmP1y, 1,
!!!			centerSegmPx, centerSegmPy, 901,
!!!			0, segmAng, 4000,
!!!			segmP1x, segmP1y, -1

		circleAcx	= circleCx
		circleAcy	= circleCy
		circleAr	= circleR

		circleBcx	= centerSegmPx
		circleBcy	= centerSegmPy
		circleBr	= segmR

		gosub "CircleCircleIntersection"

!!!		text2 0, 0, state
!!!		circle2 ipx1, ipy1, 0.01
!!!		circle2 ipx2, ipy2, 0.02

		if (state > 0) then

			! Compute vectors from segment center to segment end points
			Point1x = segmP1x
			Point1y = segmP1y
			Point1z = 0

			Point2x = centerSegmPx
			Point2y = centerSegmPy
			Point2z = 0

			gosub "GetDirectionP2toP1"

			segmVx1 = DirectionVx
			segmVy1 = DirectionVy


			Point1x = segmP2x
			Point1y = segmP2y
			Point1z = 0

			Point2x = centerSegmPx
			Point2y = centerSegmPy
			Point2z = 0

			gosub "GetDirectionP2toP1"

			segmVx2 = DirectionVx
			segmVy2 = DirectionVy

!!!			add2 centerSegmPx, centerSegmPy
!!!			line2 0, 0, segmVx1, segmVy1
!!!			line2 0, 0, segmVx2, segmVy2
!!!			del 1

			! Check first intersection point
			Point1x = ipx1
			Point1y = ipy1
			Point1z = 0

			Point2x = centerSegmPx
			Point2y = centerSegmPy
			Point2z = 0

			gosub "GetDirectionP2toP1"

			IPVx = DirectionVx
			IPVy = DirectionVy

			! Compute angle of vectors
			scalarSI = max( -1, min( 1, ( (segmVx1 * IPVx) + (segmVy1 * IPVy) ) ) )
			segmAng1 = acs(scalarSI)

			! Compute angle of vectors
			scalarSI = max( -1, min( 1, ( (segmVx2 * IPVx) + (segmVy2 * IPVy) ) ) )
			segmAng2 = acs(scalarSI)

!!!			add2 centerSegmPx, centerSegmPy
!!!			pen 20
!!!			line2 0, 0, IPVx, IPVy
!!!			del 1
!!!
!!!			text2 1, 0, segmAng1
!!!			text2 1, 1, segmAng2

			if ( ((segmAng1 + segmAng2) - abs(segmAng)) < EPS ) then		! intersection point lies on segment
				SegmCircIpx = ipx1
				SegmCircIpy = ipy1

				SegmCircIpState = 1
			endif

			! Check second intersection point
			if (state = 2) then

				Point1x = ipx2
				Point1y = ipy2
				Point1z = 0

				Point2x = centerSegmPx
				Point2y = centerSegmPy
				Point2z = 0

				gosub "GetDirectionP2toP1"

				IPVx = DirectionVx
				IPVy = DirectionVy

				! Compute angle of vectors
				scalarSI = max( -1, min( 1, ( (segmVx1 * IPVx) + (segmVy1 * IPVy) ) ) )
				segmAng1 = acs(scalarSI)

				! Compute angle of vectors
				scalarSI = max( -1, min( 1, ( (segmVx2 * IPVx) + (segmVy2 * IPVy) ) ) )
				segmAng2 = acs(scalarSI)

!!!				add2 centerSegmPx, centerSegmPy
!!!				pen 6
!!!				line2 0, 0, IPVx, IPVy
!!!				del 1
!!!
!!!				text2 3, 0, segmAng1
!!!				text2 3, 1, segmAng2

				if ( ((segmAng1 + segmAng2) - abs(segmAng)) < EPS ) then		! intersection point lies on segment
					if SegmCircIpState = 0 then
						SegmCircIpx = ipx2
						SegmCircIpy = ipy2

						SegmCircIpState = 1
					else
						SegmCircIp2x = ipx2
						SegmCircIp2y = ipy2

						SegmCircIpState = SegmCircIpState + 1
					endif
				endif

			endif

		endif

	endif

!!!	pen 20
!!!	hotspot2 SegmCircIpx, SegmCircIpy
!!!	pen 6
!!!	hotspot2 SegmCircIp2x, SegmCircIp2y
!!!
!!!	text2 -1, 0, SegmCircIpState

return

! ===============================================
! Name : PolylineDistribution
! -----------------------------------------------
! Input:
!	EPS:			epsylon
!	PolylineCoords:	polyline data array
!					[i][1]:		Coordinate X of vertex
!					[i][2]:		Coordinate Y of vertex
!					[i][3]:		angle of segment which starts from vertex
!	offsetDistributionFromStart:	offset starting of distribution from polyline start
!	offsetDistributionFromEnd:		offset ending of distribution from polyline end
!	distributionNum:				number of segments
! Output:
!	DistributorPoints:		distributor point array
!				[i][1]:		Coordinate X of distributor point
!				[i][2]:		Coordinate Y of distributor point
!				[i][3]:		Crossing vector X of distributor point
!				[i][4]:		Crossing vector Y of distributor point
!				[i][5]:		index of segment which contains the distributor point
! Called subroutines:
!	InsertPointToSegment
! ===============================================

"PolylineDistribution":

	POLYLINE_COORD_X	= 1
	POLYLINE_COORD_Y	= 2
	POLYLINE_ANGLE		= 3

	offsetDistributionFromStart	= abs(offsetDistributionFromStart)
	offsetDistributionFromEnd	= abs(offsetDistributionFromEnd)

	! Compute full length of polyline and lengths by segments
	! -------------------------------------------------------
	dim PolylineSegmLength[]	! Length of array one less than PolylineCoords array
	iSegm = 0

	fullLength = 0

	nVert = vardim1(PolylineCoords)
	for iVert = 1 to nVert

		if (iVert < nVert) then

			arcAngle = PolylineCoords[iVert][POLYLINE_ANGLE]

			CurrentPx = PolylineCoords[iVert][POLYLINE_COORD_X]
			CurrentPy = PolylineCoords[iVert][POLYLINE_COORD_Y]

			NextPx	= PolylineCoords[iVert + 1][POLYLINE_COORD_X]
			NextPy	= PolylineCoords[iVert + 1][POLYLINE_COORD_Y]

			Distance = Sqr((CurrentPx - NextPx)^2 + (CurrentPy - NextPy)^2)

			if ( abs(arcAngle) < EPS ) then
				fullLength = fullLength + Distance
			else
				arcR = (Distance / 2) / sin(abs(arcAngle / 2))

				Distance = abs( arcR*(pi/180)*arcAngle )

				fullLength = fullLength + Distance
			endif

			iSegm = iSegm + 1
			PolylineSegmLength[iSegm] = Distance
		endif
	next iVert

	nDistributorPoints = 0

	if (fullLength > EPS) & ( fullLength > (offsetDistributionFromStart + offsetDistributionFromEnd) ) & (distributionNum > 0) then

		DISTRIBUTOR_COORD_X		= 1
		DISTRIBUTOR_COORD_Y		= 2
		DISTRIBUTOR_VECTOR_X	= 3
		DISTRIBUTOR_VECTOR_Y	= 4
		DISTRIBUTOR_SEGM_ID		= 5

		iDistributorPoint = 0
		pointInterval = (fullLength - offsetDistributionFromStart - offsetDistributionFromEnd) / distributionNum

		! Set distributor point distance from start of polyline
		! -----------------------------------------------------
		dim distributorPointDistance[]
		Distance = 0
		for iPoint = 1 to distributionNum + 1
			if (iPoint = 1) then
				Distance = Distance + offsetDistributionFromStart
			else
				Distance = Distance + pointInterval
			endif

			distributorPointDistance[iPoint] = Distance
		next iPoint


		! Placing of distributor points on polyline
		! -----------------------------------------
		nPoint = vardim1(distributorPointDistance)
		nSegm = vardim1(PolylineSegmLength)

		for iPoint = 1 to nPoint

			controlDistance = distributorPointDistance[iPoint]

			currSegmSumLength		= 0
			previousSegmSumLength 	= 0

			for iSegm = 1 to nSegm

				segmLength = PolylineSegmLength[iSegm]
				currSegmSumLength = currSegmSumLength + segmLength

				if (iPoint = 1) then
					bFittingPoint = ( controlDistance > (previousSegmSumLength - EPS) ) & ( controlDistance < (currSegmSumLength + EPS) )
				else
					bFittingPoint = ( controlDistance > (previousSegmSumLength + EPS) ) & ( controlDistance < (currSegmSumLength + EPS) )
				endif

				if bFittingPoint then

					iCurrVert = iSegm
					iNextVert = iCurrVert + 1

					segmentStartPx	= PolylineCoords[iCurrVert][POLYLINE_COORD_X]
					segmentStartPy	= PolylineCoords[iCurrVert][POLYLINE_COORD_Y]
					segmentEndPx	= PolylineCoords[iNextVert][POLYLINE_COORD_X]
					segmentEndPy	= PolylineCoords[iNextVert][POLYLINE_COORD_Y]
					segmentAngle	= PolylineCoords[iCurrVert][POLYLINE_ANGLE]

					insertedPx	= 0
					insertedPy	= 0
					insertAngle	= 0

					insertionToPx	= segmentStartPx
					insertionToPy	= segmentStartPy
					benchmarkPx		= segmentEndPx
					benchmarkPy		= segmentEndPy
					segmentAngle	= segmentAngle
					insertionDist	= controlDistance - previousSegmSumLength

					gosub "InsertPointToSegment"

					! Looking for matching point
					bMatchWithPolylineStart	= ( abs(controlDistance) < EPS )
					bMatchWithPolylineEnd	= ( abs(controlDistance - fullLength) < EPS )

					bMatchWithPolylineCorner = 0
					if not(bMatchWithPolylineStart | bMatchWithPolylineEnd) then
						bMatchWithPolylineCorner = ( abs(insertionDist - segmLength) < EPS )
					endif

					! 
					if bMatchWithPolylineCorner then

						! Direction of current segment from matching corner point
						if ( abs(segmentAngle) < EPS ) then

							! Straight segment
							Point1x = segmentStartPx
							Point1y = segmentStartPy
							Point1z = 0

							Point2x = segmentEndPx
							Point2y = segmentEndPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							currentSegmVx = DirectionVx
							currentSegmVy = DirectionVy

						else

							! Arched segment
							! Looking for arch center point
							Point1x = segmentEndPx
							Point1y = segmentEndPy
							Point1z = 0

							Point2x = segmentStartPx
							Point2y = segmentStartPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							arcR = (Distance/2) / sin(abs(segmentAngle/2))

							if ((segmentAngle < 0) & (segmentAngle > -180)) | (segmentAngle > 180) then
								ArcDirectionVx = -DirectionVy
								ArcDirectionVy = DirectionVx
							else
								ArcDirectionVx = DirectionVy
								ArcDirectionVy = -DirectionVx
							endif

							centerArcPx = segmentStartPx + (Distance/2) * DirectionVx - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVx
							centerArcPy = segmentStartPy + (Distance/2) * DirectionVy - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVy

							Point1x = centerArcPx
							Point1y = centerArcPy
							Point1z = 0

							Point2x = segmentEndPx
							Point2y = segmentEndPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							if (segmentAngle > 0) then
								currentSegmVx = -DirectionVy
								currentSegmVy = DirectionVx
							else
								currentSegmVx = DirectionVy
								currentSegmVy = -DirectionVx
							endif

!!!							pen 6
!!!							circle2 (segmentStartPx + segmentEndPx)/2, (segmentStartPy + segmentEndPy)/2, 0.02
!!!							text2 (segmentStartPx + segmentEndPx)/2, (segmentStartPy + segmentEndPy)/2, segmentAngle
!!!							circle2 centerArcPx, centerArcPy, 0.04

						endif

!!!						pen 6
!!!						add2 segmentEndPx, segmentEndPy
!!!						line2 0, 0, currentSegmVx/3, currentSegmVy/3
!!!						del 1

						! Direction of next segment from matching corner point
						nextSegmentAngle = PolylineCoords[iNextVert][POLYLINE_ANGLE]

						if ( abs(nextSegmentAngle) < EPS ) then

							! Straight segment
							Point1x = PolylineCoords[iNextVert + 1][POLYLINE_COORD_X]
							Point1y = PolylineCoords[iNextVert + 1][POLYLINE_COORD_Y]
							Point1z = 0

							Point2x = segmentEndPx
							Point2y = segmentEndPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							nextSegmVx = DirectionVx
							nextSegmVy = DirectionVy

						else

							! Arched segment
							Point1x = PolylineCoords[iNextVert + 1][POLYLINE_COORD_X]
							Point1y = PolylineCoords[iNextVert + 1][POLYLINE_COORD_Y]
							Point1z = 0

							Point2x = segmentEndPx
							Point2y = segmentEndPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							arcR = (Distance/2) / sin(abs(nextSegmentAngle/2))

							if ((nextSegmentAngle < 0) & (nextSegmentAngle > -180)) | (nextSegmentAngle > 180) then
								ArcDirectionVx = -DirectionVy
								ArcDirectionVy = DirectionVx
							else
								ArcDirectionVx = DirectionVy
								ArcDirectionVy = -DirectionVx
							endif

							centerArcPx = segmentEndPx + (Distance/2) * DirectionVx - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVx
							centerArcPy = segmentEndPy + (Distance/2) * DirectionVy - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVy

							Point1x = centerArcPx
							Point1y = centerArcPy
							Point1z = 0

							Point2x = segmentEndPx
							Point2y = segmentEndPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							if (nextSegmentAngle > 0) then
								nextSegmVx = DirectionVy
								nextSegmVy = -DirectionVx
							else
								nextSegmVx = -DirectionVy
								nextSegmVy = DirectionVx
							endif

!!!							pen 20
!!!							circle2 (PolylineCoords[iNextVert + 1][POLYLINE_COORD_X] + segmentEndPx)/2, (PolylineCoords[iNextVert + 1][POLYLINE_COORD_Y] + segmentEndPy)/2, 0.01
!!!							text2 (PolylineCoords[iNextVert + 1][POLYLINE_COORD_X] + segmentEndPx)/2 + 0.01, (PolylineCoords[iNextVert + 1][POLYLINE_COORD_Y] + segmentEndPy)/2 - 0.01, nextSegmentAngle
!!!							circle2 centerArcPx, centerArcPy, 0.02

						endif

!!!						pen 20
!!!						add2 segmentEndPx, segmentEndPy
!!!						line2 0, 0, nextSegmVx/3, nextSegmVy/3
!!!						del 1

						! Compute crossing direction in matching point
						crossingDVx = (currentSegmVx + nextSegmVx)/2
						crossingDVy = (currentSegmVy + nextSegmVy)/2

						distV = sqr(crossingDVx^2 + crossingDVy^2)

						if ( abs(distV) < EPS ) then
							crossingDVx = nextSegmVy
							crossingDVy = -nextSegmVx
						else
							crossingDVx = crossingDVx / distV
							crossingDVy = crossingDVy / distV
						endif

						! Change direction to positive side
						scalar = (crossingDVx * nextSegmVy) + (crossingDVy * (-nextSegmVx))
						if (scalar < 0)  then
							crossingDVx = -crossingDVx
							crossingDVy = -crossingDVy
						endif

						iDistributorPoint = iDistributorPoint + 1
						DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_X]	= insertedPx
						DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_Y]	= insertedPy
						DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_X]	= crossingDVx
						DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_Y]	= crossingDVy
						DistributorPoints[iDistributorPoint][DISTRIBUTOR_SEGM_ID]	= iSegm

!!!						pen 38
!!!						add2 insertedPx, insertedPy
!!!						circle2 0, 0, 0.02
!!!						line2 0, 0, 0.2*crossingDVx, 0.2*crossingDVy
!!!						del 1

					else

						if ( abs(segmentAngle) < EPS ) then

							! Straight segment
							! Compute crossing direction in insertion point
							Point1x = segmentEndPx
							Point1y = segmentEndPy
							Point1z = 0

							Point2x = segmentStartPx
							Point2y = segmentStartPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							crossingDVx = DirectionVy
							crossingDVy = -DirectionVx

							iDistributorPoint = iDistributorPoint + 1
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_X]	= insertedPx
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_Y]	= insertedPy
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_X]	= crossingDVx
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_Y]	= crossingDVy
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_SEGM_ID]	= iSegm

!!!							pen 40
!!!							add2 insertedPx, insertedPy
!!!							circle2 0, 0, 0.02
!!!							line2 0, 0, 0.2*crossingDVx, 0.2*crossingDVy
!!!							del 1

						else

							! Arched segment
							! Looking for arch center point
							Point1x = segmentEndPx
							Point1y = segmentEndPy
							Point1z = 0

							Point2x = segmentStartPx
							Point2y = segmentStartPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							arcR = (Distance/2) / sin(abs(segmentAngle/2))

							if ((segmentAngle < 0) & (segmentAngle > -180)) | (segmentAngle > 180) then
								ArcDirectionVx = -DirectionVy
								ArcDirectionVy = DirectionVx
							else
								ArcDirectionVx = DirectionVy
								ArcDirectionVy = -DirectionVx
							endif

							centerArcPx = segmentStartPx + (Distance/2) * DirectionVx - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVx
							centerArcPy = segmentStartPy + (Distance/2) * DirectionVy - (sqr((arcR)^2 - (Distance/2)^2)) * ArcDirectionVy

							! Compute crossing direction in insertion point
							Point1x = insertedPx
							Point1y = insertedPy
							Point1z = 0

							Point2x = centerArcPx
							Point2y = centerArcPy
							Point2z = 0

							gosub "GetDirectionP2toP1"

							if (segmentAngle > 0) then
								crossingDVx = DirectionVx
								crossingDVy = DirectionVy
							else
								crossingDVx = -DirectionVx
								crossingDVy = -DirectionVy
							endif

							iDistributorPoint = iDistributorPoint + 1
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_X]	= insertedPx
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_COORD_Y]	= insertedPy
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_X]	= crossingDVx
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_VECTOR_Y]	= crossingDVy
							DistributorPoints[iDistributorPoint][DISTRIBUTOR_SEGM_ID]	= iSegm

!!!							pen 40
!!!							add2 insertedPx, insertedPy
!!!							circle2 0, 0, 0.02
!!!							line2 0, 0, 0.2*crossingDVx, 0.2*crossingDVy
!!!							del 1

						endif

					endif

				endif

				! Set segment summa length to next checking
				! -----------------------------------------
				previousSegmSumLength = currSegmSumLength
			next iSegm

		next iPoint

		nDistributorPoints = iDistributorPoint

	endif

return
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_UIDefault/>
			<STBit_FixSize/>
			<STBit_UIUseHierarchicalPages/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="iFunction">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- PolygonLineIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PolygonLineIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of a Polygon and a Line"]]></Description>
		</Title>
		<Length Name="PolyCoords">
			<Description><![CDATA["Polygon Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="vx">
			<Description><![CDATA["Direction vector X of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="vy">
			<Description><![CDATA["Direction vector Y of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="px">
			<Description><![CDATA["Coordinate X of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="py">
			<Description><![CDATA["Coordinate Y of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- SegmentLineIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SegmentLineIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of Segment and Line"]]></Description>
		</Title>
		<Length Name="line_vx">
			<Description><![CDATA["Direction vector X of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="line_vy">
			<Description><![CDATA["Direction vector Y of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="line_px">
			<Description><![CDATA["Coordinate X of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="line_py">
			<Description><![CDATA["Coordinate Y of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segment_p1x">
			<Description><![CDATA["Segment startpoint X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segment_p1y">
			<Description><![CDATA["Segment startpoint Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segment_p2x">
			<Description><![CDATA["Segment endpoint X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segment_p2y">
			<Description><![CDATA["Segment endpoint Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="segment_ang">
			<Description><![CDATA["Segment Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- CircleLineIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="CircleLineIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of Circle and Line"]]></Description>
		</Title>
		<Length Name="xo">
			<Description><![CDATA["Circle Center Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="yo">
			<Description><![CDATA["Circle Center Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ro">
			<Description><![CDATA["Circle Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lineVx">
			<Description><![CDATA["Direction vector X of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lineVy">
			<Description><![CDATA["Direction vector Y of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="linePx">
			<Description><![CDATA["Coordinate X of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="linePy">
			<Description><![CDATA["Coordinate Y of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- LineLineIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="LineLineIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of Two Lines"]]></Description>
		</Title>
		<Length Name="vx1">
			<Description><![CDATA["Direction vector X of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="vy1">
			<Description><![CDATA["Direction vector Y of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="px1">
			<Description><![CDATA["Coordinate X of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="py1">
			<Description><![CDATA["Coordinate Y of a point of the line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="vx2">
			<Description><![CDATA["Direction vector X of the second line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="vy2">
			<Description><![CDATA["Direction vector Y of the second line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="px2">
			<Description><![CDATA["Coordinate X of a point of the second line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="py2">
			<Description><![CDATA["Coordinate Y of a point of the second line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- GetDirectionP2toP1Params: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="GetDirectionP2toP1Params">
			<Description><![CDATA["Inputs for Direction between Two Points"]]></Description>
		</Title>
		<Length Name="Point1x">
			<Description><![CDATA["Coordinate X of the first point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point1y">
			<Description><![CDATA["Coordinate Y of the first point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point1z">
			<Description><![CDATA["Coordinate Z of the first point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point2x">
			<Description><![CDATA["Coordinate X of the second point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point2y">
			<Description><![CDATA["Coordinate Y of the second point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point2z">
			<Description><![CDATA["Coordinate Z of the second point"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- BasicGeome_A: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="BasicGeome_A">
			<Description><![CDATA["Inputs for Intersection of Two Lines By Dot"]]></Description>
		</Title>
		<Length Name="Point3x">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point3y">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point3z">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point4x">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point4y">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="Point4z">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- GetSegmentDirectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="GetSegmentDirectionParams">
			<Description><![CDATA["Inputs for Direction on Starting and Ending of Segment"]]></Description>
		</Title>
		<Length Name="startPx">
			<Description><![CDATA["Segment Starting Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="startPy">
			<Description><![CDATA["Segment Starting Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="endPx">
			<Description><![CDATA["Segment Ending Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="endPy">
			<Description><![CDATA["Segment Ending Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="arcAngle">
			<Description><![CDATA["Segment Arch angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- GetMirroredVector: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="GetMirroredVector">
			<Description><![CDATA["Inputs to Mirror a Vector"]]></Description>
		</Title>
		<Length Name="mirrorVx">
			<Description><![CDATA["Direction X of Mirroring Vector"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="mirrorVy">
			<Description><![CDATA["Direction Y of Mirroring Vector"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="inputVx">
			<Description><![CDATA["Direction X of Vector which has to Mirror"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="inputVy">
			<Description><![CDATA["Direction Y of Vector which has to Mirror"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- InsertPointToSegment: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="InsertPointToSegment">
			<Description><![CDATA["Inputs to Insert Point to Segment"]]></Description>
		</Title>
		<Length Name="insertionToPx">
			<Description><![CDATA["Insert Point to this Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="insertionToPy">
			<Description><![CDATA["Insert Point to this Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="benchmarkPx">
			<Description><![CDATA["Benchmark Point X to Control Direction of Insertion"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="benchmarkPy">
			<Description><![CDATA["Benchmark Point Y to Control Direction of Insertion"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="segmentAngle">
			<Description><![CDATA["Angle of Arched Segment"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="insertionDist">
			<Description><![CDATA["Insertion Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- SegmentsOfArc: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SegmentsOfArc">
			<Description><![CDATA["Arc Segmentation"]]></Description>
		</Title>
		<Length Name="TolerDiff">
			<Description><![CDATA["Tolerance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- CircleCircleIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="CircleCircleIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of Two Circle"]]></Description>
		</Title>
		<Length Name="circleAcx">
			<Description><![CDATA["Circle A Center Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="circleAcy">
			<Description><![CDATA["Circle A Center Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="circleAr">
			<Description><![CDATA["Circle A Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.5</Value>
		</Length>
		<Length Name="circleBcx">
			<Description><![CDATA["Circle B Center Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="circleBcy">
			<Description><![CDATA["Circle B Center Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.5</Value>
		</Length>
		<Length Name="circleBr">
			<Description><![CDATA["Circle B Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>

		<!-- SegmentCircleIntersectionParams: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SegmentCircleIntersectionParams">
			<Description><![CDATA["Inputs for Intersection of Segment and Line"]]></Description>
		</Title>
		<Length Name="circleCx">
			<Description><![CDATA["Circle Center Point X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="circleCy">
			<Description><![CDATA["Circle Center Point Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="circleR">
			<Description><![CDATA["Circle Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="segmP1x">
			<Description><![CDATA["Segment startpoint X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segmP1y">
			<Description><![CDATA["Segment startpoint Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segmP2x">
			<Description><![CDATA["Segment endpoint X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="segmP2y">
			<Description><![CDATA["Segment endpoint Y"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="segmAng">
			<Description><![CDATA["Segment Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- PolylineDistribution: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PolylineDistribution">
			<Description><![CDATA["Inputs for Distribution a Polyline"]]></Description>
		</Title>
		<Length Name="PolylineCoords">
			<Description><![CDATA["Polygonline Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="offsetDistributionFromStart">
			<Description><![CDATA["Offset Starting of Distribution from Polyline Start"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetDistributionFromEnd">
			<Description><![CDATA["Offset Starting of Distribution from Polyline Start"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="distributionNum">
			<Description><![CDATA["Number of Segments"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
	</Parameters>
</ParamSection>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

</Symbol>
